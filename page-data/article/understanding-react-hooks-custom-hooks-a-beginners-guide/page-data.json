{"componentChunkName":"component---src-templates-post-js","path":"/article/understanding-react-hooks-custom-hooks-a-beginners-guide/","result":{"data":{"ghostPost":{"id":"Ghost__Post__63ae8ff9bb0c2e69d86450df","title":"Understanding React Hooks & Custom Hooks: A Beginner's Guide","slug":"understanding-react-hooks-custom-hooks-a-beginners-guide","featured":false,"feature_image":"https://images.unsplash.com/photo-1633356122102-3fe601e05bd2?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxMTc3M3wwfDF8c2VhcmNofDF8fHJlYWN0fGVufDB8fHx8MTY3MjM4NTUxNg&ixlib=rb-4.0.3&q=80&w=2000","excerpt":"React Hooks are a new feature in React that allows you to use state and other React features without writing a class. They were introduced in React 16.8 and have been widely adopted as a way to write functional and reusable components.","custom_excerpt":"React Hooks are a new feature in React that allows you to use state and other React features without writing a class. They were introduced in React 16.8 and have been widely adopted as a way to write functional and reusable components.","visibility":"public","created_at_pretty":"30 December, 2022","published_at_pretty":"25 February, 2022","updated_at_pretty":"30 December, 2022","created_at":"2022-12-30T07:15:05.000+00:00","published_at":"2022-02-25T07:35:00.000+00:00","updated_at":"2022-12-30T09:48:14.000+00:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"M. Mursaleen","slug":"m","bio":null,"profile_image":null,"twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"M. Mursaleen","slug":"m","bio":null,"profile_image":null,"twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"React","slug":"react","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"React","slug":"react","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Frontend Development","slug":"frontend-development","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Introduction\n\nReact Hooks are a new feature in React that allows you to use state and other React features without writing a class. They were introduced in React 16.8 and have been widely adopted as a way to write functional and reusable components.\n\n\nReact Hooks by exmaple\n\nHere's an example of how you can use the useState hook to add state to a functional component:\n\nimport { useState } from 'react';\n\nfunction Example() {\n  // Declare a new state variable, which we'll call \"count\"\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n\nThe useState hook takes a single argument, which is the initial state, and returns an array with two elements: the current state and a function to update it. In the example above, we declare a new state variable called count with an initial value of 0, and a function called setCount to update it.\n\nThere are many other React Hooks that you can use to perform different tasks, such as useEffect, useContext, and useReducer. You can find out more about them in the React documentation.\n\n\nDefault React Hooks\n\nHere is a list of all the React Hooks that are currently available in the latest version of React:\n\n * useState: This hook allows you to add state to functional components. It takes a single argument, which is the initial state, and returns an array with two elements: the current state and a function to update it.\n * useEffect: This hook allows you to perform side effects in functional components. It takes a function as an argument, which will be called after the component has rendered. You can use it to perform tasks such as fetching data or setting up subscriptions.\n * useContext: This hook allows you to access the value of a context object in a functional component. It takes a context object as an argument and returns the current context value.\n * useReducer: This hook allows you to use a reducer function to manage state in a functional component. It takes a reducer function and an initial state as arguments, and returns the current state and a dispatch function.\n * useCallback: This hook returns a memoized callback function. It can be used to optimize the performance of components that rely on props or state changes.\n * useMemo: This hook returns a memoized value. It can be used to optimize the performance of expensive calculations in a component.\n * useRef: This hook returns a mutable ref object whose .current property is initialized to the passed argument (initialValue). The returned object will persist for the full lifetime of the component.\n * useImperativeHandle: This hook allows you to customize the instance value that is exposed to parent components when using ref. It takes a ref and a createHandle function as arguments.\n * useLayoutEffect: This hook is similar to useEffect, but it fires synchronously after all DOM mutations. It should be used sparingly, because it blocks the browser from updating the screen until the effect has finished.\n * useDebugValue: This hook can be used to display a label for a custom hook in the React DevTools profiler. It takes a value as an argument and displays it next to the hook's name in the Profiler.\n\n\nCustom Hooks\n\nCustom Hooks are a new feature in React that allows you to extract component logic into reusable functions. They are a way to share logic across components, and they make it easier to reuse code and write testable components.\n\nHere's an example of a custom hook that extracts the logic for fetching data from a REST API:\n\nimport { useState, useEffect } from 'react';\n\nfunction useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    async function fetchData() {\n      try {\n        const response = await fetch(url);\n        const data = await response.json();\n        setData(data);\n      } catch (error) {\n        setError(error);\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    fetchData();\n  }, [url]);\n\n  return { data, loading, error };\n}\n\nTo use this custom hook, you can import it into your component and call it inside the component's function body:\n\nimport { useFetch } from './useFetch';\n\nfunction MyComponent() {\n  const { data, loading, error } = useFetch('https://api.example.com/endpoint');\n\n  if (loading) {\n    return <p>Loading...</p>;\n  }\n\n  if (error) {\n    return <p>Error: {error.message}</p>;\n  }\n\n  return <p>Data: {data}</p>;\n}\n\nCustom Hooks follow the same naming convention as regular React Hooks, starting with the word use and using camelCase. They can call other Hooks and can be composed to build more complex logic.\n\n\ntl;dr\n\nReact Hooks are a new feature in React that allow you to use state and other React features without writing a class. They are a way to share logic across components, and they make it easier to reuse code and write testable components. There are several built-in Hooks, such as useState, useEffect, and useContext, that perform different tasks.\n\nYou can also create your own custom Hooks by extracting component logic into reusable functions. Custom Hooks follow the same naming convention as regular React Hooks, starting with the word use and using camelCase. They can be called inside the function body of a component and can be composed to build more complex logic.","html":"<h2 id=\"introduction\">Introduction</h2><p>React Hooks are a new feature in React that allows you to use state and other React features without writing a class. They were introduced in React 16.8 and have been widely adopted as a way to write functional and reusable components.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://images.unsplash.com/photo-1570353825353-5daea21cdc4d?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDJ8fGhvb2t8ZW58MHx8fHwxNjcyMzg1Njc1&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000\" class=\"kg-image\" alt loading=\"lazy\" width=\"3456\" height=\"5184\" srcset=\"https://images.unsplash.com/photo-1570353825353-5daea21cdc4d?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDJ8fGhvb2t8ZW58MHx8fHwxNjcyMzg1Njc1&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=600 600w, https://images.unsplash.com/photo-1570353825353-5daea21cdc4d?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDJ8fGhvb2t8ZW58MHx8fHwxNjcyMzg1Njc1&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=1000 1000w, https://images.unsplash.com/photo-1570353825353-5daea21cdc4d?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDJ8fGhvb2t8ZW58MHx8fHwxNjcyMzg1Njc1&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=1600 1600w, https://images.unsplash.com/photo-1570353825353-5daea21cdc4d?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDJ8fGhvb2t8ZW58MHx8fHwxNjcyMzg1Njc1&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2400 2400w\" sizes=\"(min-width: 720px) 720px\"><figcaption>Photo by <a href=\"https://unsplash.com/@mael_balland?utm_source=ghost&utm_medium=referral&utm_campaign=api-credit\">Mael BALLAND</a> / <a href=\"https://unsplash.com/?utm_source=ghost&utm_medium=referral&utm_campaign=api-credit\">Unsplash</a></figcaption></figure><h2 id=\"react-hooks-by-exmaple\">React Hooks by exmaple</h2><p>Here's an example of how you can use the <code>useState</code> hook to add state to a functional component:</p><pre><code class=\"language-javascript\">import { useState } from 'react';\n\nfunction Example() {\n  // Declare a new state variable, which we'll call \"count\"\n  const [count, setCount] = useState(0);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;You clicked {count} times&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;\n        Click me\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code></pre><p>The <code>useState</code> hook takes a single argument, which is the initial state, and returns an array with two elements: the current state and a function to update it. In the example above, we declare a new state variable called <code>count</code> with an initial value of <code>0</code>, and a function called <code>setCount</code> to update it.</p><p>There are many other React Hooks that you can use to perform different tasks, such as <code>useEffect</code>, <code>useContext</code>, and <code>useReducer</code>. You can find out more about them in the React documentation.</p><h2 id=\"default-react-hooks\">Default React Hooks</h2><p>Here is a list of all the React Hooks that are currently available in the latest version of React:</p><ul><li><code>useState</code>: This hook allows you to add state to functional components. It takes a single argument, which is the initial state, and returns an array with two elements: the current state and a function to update it.</li><li><code>useEffect</code>: This hook allows you to perform side effects in functional components. It takes a function as an argument, which will be called after the component has rendered. You can use it to perform tasks such as fetching data or setting up subscriptions.</li><li><code>useContext</code>: This hook allows you to access the value of a context object in a functional component. It takes a context object as an argument and returns the current context value.</li><li><code>useReducer</code>: This hook allows you to use a reducer function to manage state in a functional component. It takes a reducer function and an initial state as arguments, and returns the current state and a dispatch function.</li><li><code>useCallback</code>: This hook returns a memoized callback function. It can be used to optimize the performance of components that rely on props or state changes.</li><li><code>useMemo</code>: This hook returns a memoized value. It can be used to optimize the performance of expensive calculations in a component.</li><li><code>useRef</code>: This hook returns a mutable ref object whose .current property is initialized to the passed argument (initialValue). The returned object will persist for the full lifetime of the component.</li><li><code>useImperativeHandle</code>: This hook allows you to customize the instance value that is exposed to parent components when using ref. It takes a ref and a createHandle function as arguments.</li><li><code>useLayoutEffect</code>: This hook is similar to <code>useEffect</code>, but it fires synchronously after all DOM mutations. It should be used sparingly, because it blocks the browser from updating the screen until the effect has finished.</li><li><code>useDebugValue</code>: This hook can be used to display a label for a custom hook in the React DevTools profiler. It takes a value as an argument and displays it next to the hook's name in the Profiler.</li></ul><h2 id=\"custom-hooks\">Custom Hooks</h2><p>Custom Hooks are a new feature in React that allows you to extract component logic into reusable functions. They are a way to share logic across components, and they make it easier to reuse code and write testable components.</p><p>Here's an example of a custom hook that extracts the logic for fetching data from a REST API:</p><pre><code class=\"language-javascript\">import { useState, useEffect } from 'react';\n\nfunction useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() =&gt; {\n    async function fetchData() {\n      try {\n        const response = await fetch(url);\n        const data = await response.json();\n        setData(data);\n      } catch (error) {\n        setError(error);\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    fetchData();\n  }, [url]);\n\n  return { data, loading, error };\n}</code></pre><p>To use this custom hook, you can import it into your component and call it inside the component's function body:</p><pre><code class=\"language-javascript\">import { useFetch } from './useFetch';\n\nfunction MyComponent() {\n  const { data, loading, error } = useFetch('https://api.example.com/endpoint');\n\n  if (loading) {\n    return &lt;p&gt;Loading...&lt;/p&gt;;\n  }\n\n  if (error) {\n    return &lt;p&gt;Error: {error.message}&lt;/p&gt;;\n  }\n\n  return &lt;p&gt;Data: {data}&lt;/p&gt;;\n}</code></pre><p>Custom Hooks follow the same naming convention as regular React Hooks, starting with the word <code>use</code> and using camelCase. They can call other Hooks and can be composed to build more complex logic.</p><h2 id=\"tldr\">tl;dr</h2><p>React Hooks are a new feature in React that allow you to use state and other React features without writing a class. They are a way to share logic across components, and they make it easier to reuse code and write testable components. There are several built-in Hooks, such as <code>useState</code>, <code>useEffect</code>, and <code>useContext</code>, that perform different tasks.</p><p>You can also create your own custom Hooks by extracting component logic into reusable functions. Custom Hooks follow the same naming convention as regular React Hooks, starting with the word <code>use</code> and using camelCase. They can be called inside the function body of a component and can be composed to build more complex logic.</p>","url":"https://portfolioghost.phonemall.pk/understanding-react-hooks-custom-hooks-a-beginners-guide/","canonical_url":null,"uuid":"cd28da39-4a65-45f5-b840-c0ba1bc7f3b6","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"63ae8ff9bb0c2e69d86450df","reading_time":4}},"pageContext":{"slug":"understanding-react-hooks-custom-hooks-a-beginners-guide"}},"staticQueryHashes":["1752937443","2358152166","2561578252","2731221146","4145280475"]}