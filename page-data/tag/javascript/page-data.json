{"componentChunkName":"component---src-templates-tag-js","path":"/tag/javascript/","result":{"data":{"ghostTag":{"slug":"javascript","name":"Javascript","visibility":"public","feature_image":null,"description":null,"meta_title":null,"meta_description":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__63b16ba1bb0c2e69d86452bb","title":"Understanding Referential Equality in React","slug":"understanding-referential-equality-in-react","featured":false,"feature_image":"https://images.unsplash.com/photo-1591267990532-e5bdb1b0ceb8?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxMTc3M3wwfDF8c2VhcmNofDl8fFJlYWN0fGVufDB8fHx8MTY3MjU3MjQ5NQ&ixlib=rb-4.0.3&q=80&w=2000","excerpt":"Ignoring the Referential Equality introduces minor bugs as discussed above. But, when developing React components, we use effects (useEffect) and memorized callbacks (useCallback) that get triggered only when a value in their dependency array changes.","custom_excerpt":"Ignoring the Referential Equality introduces minor bugs as discussed above. But, when developing React components, we use effects (useEffect) and memorized callbacks (useCallback) that get triggered only when a value in their dependency array changes.","visibility":"public","created_at_pretty":"01 January, 2023","published_at_pretty":"11 July, 2022","updated_at_pretty":"01 January, 2023","created_at":"2023-01-01T11:16:49.000+00:00","published_at":"2022-07-11T11:26:00.000+00:00","updated_at":"2023-01-01T11:28:32.000+00:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"M. Mursaleen","slug":"m","bio":null,"profile_image":null,"twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"M. Mursaleen","slug":"m","bio":null,"profile_image":null,"twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Javascript","slug":"javascript","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Javascript","slug":"javascript","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"React","slug":"react","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Frontend Development","slug":"frontend-development","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"What is referential equality? Why it is useful to understand, and how referential equality affects component re-rendering in React\n\nIn React, state variables are used to render the component state on the browser. When the state changes, React re-renders the component with the new data. It helps keep the user informed of all changes occurring in the application.\n\nHowever, many React developers do not manage the state variables properly. This results in re-renders not occurring despite the state changing. It will then make an awful user experience in the application.\n\nTherefore, this article will explain how React re-renders a component and what we can do to ensure that the state changes get reflected in the UI smoothly.\n\n\nHow Does React Determine a Component Re-Render?\n\nReact re-renders a component only when a change occurs to its state variables or props.\n\nThis is shown in the example given below:\n\nconst [name, setName] = useState('');\nconst onButtonClick = (newName: string)=> {\n   setName(newName);\n};\n\nThe code snippet displayed above has a method named onButtonClick that updates the state variable - name with a new value.\n\nReact compares the new value against the old value for equality using the Object.is() comparison algorithm whenever a new value is assigned to name variable.\n\nIf the values are equal, React bails out the re-render. But if the values are different, React triggers a component re-render to reflect the state change.\n\n\nThe Comparison Algorithm — Object.is()\n\nThe Object.is() algorithm determines whether two values are the same if:\n\n 1. Both values are undefined or null.\n 2. Both values are either true or false.\n 3. Both values are Strings having the same characters, length, and order.\n 4. Both values are Numbers with the same value or NaN.\n 5. Both values are Objects that point to one memory location.\n\nReact applies these rules to re-render components whenever a state change is made.\n\n\nThe Comparison Algorithm in Action — Referential Equality\n\nConsider the code shown below to identify how developers can introduce bugs with state management using React to understand Object.is() better.\n\nimport { useState } from 'react';\nimport './App.css';\n\nconst App = () => {\n  const [mySelf, setMySelf] = useState<{ name: string, age: number }>({ name: 'David', age: 30 });\n\n  const changeNameToJohn = () => {\n    mySelf.name = \"John\";\n    mySelf.age = 30;\n    console.log(mySelf);\n    setMySelf(mySelf)\n  }\n\n  return (\n    <div className=\"container\">\n      <div className=\"row\">\n        <div className=\"col-sm-12\" style={{ textAlign: 'center', padding: 30 }}>\n          <p>My name is {mySelf.name} and I am {mySelf.age} years of age.</p>\n          <button className=\"btn btn-primary\" onClick={changeNameToJohn}>Change My Name To John</button>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n\nThe code snippet above shows a state variable named mySelf initialized as an object with properties name and age set to \"David\" and \"30\", respectively. Furthermore, an event listener named changeNameToJohn is declared to change the name to a new value, \"John.\"\n\nThe output of this code is shown below:\n\nWhen the button clicks, the name should change to “John” and trigger a re-render to update the UI.\n\nBut, currently, it does not happen even-though logging the object displays the updated values, as shown below:\n\nMany of you may wonder why the component does not get re-rendered. Looking at the fifth principle of the Object.is() algorithm may help you understand this situation.\n\nTwo values are considered equal when both are objects that point to the exact memory location.\n\nWith the help of this principle, the bug in the above code can be identified.\n\nconst changeNameToJohn = () => {\n   mySelf.name = \"John\";\n   mySelf.age = 30;\n   console.log(mySelf);\n   setMySelf(mySelf);\n};\n\nDuring the state change shown above, it assigns the new name to the property of the current object. When the comparison algorithm gets applied by React, the new and current values will still be equal because, behind the scenes, the two values point to the exact memory location.\n\nTherefore, React classifies these values as equal and does not trigger a re-render. Hence, the UI does not reflect the state change.\n\nThis process is called Referential Equality, for objects are considered equal based on their memory location and not the values.\n\n\nProblems with the Referential Equality\n\nIgnoring the Referential Equality introduces minor bugs as discussed above. But, when developing React components, we use effects (useEffect) and memorized callbacks (useCallback) that get triggered only when a value in their dependency array changes.\n\nOne minor state management error creates numerous bugs throughout the component in situations like this.\n\nFor example, consider the code snippet shown below:\n\nimport { useCallback, useEffect, useState } from 'react';\nimport './App.css';\n\nconst App = () => {\n  const [mySelf, setMySelf] = useState<{ name: string, age: number }>({ name: 'David', age: 30 });\n  const [header, setHeader] = useState<string>('Hello David!');\n\n  const changeNameToJohn = () => {\n    mySelf.name = \"John\";\n    mySelf.age = 30;\n    console.log(mySelf);\n    setMySelf(mySelf);\n  }\n  const constructTheNameChangeMessage = useCallback(() => {\n    if (mySelf) {\n      setHeader(`Hello ${mySelf.name}!`);\n    }\n  }, [mySelf]);\n\n  useEffect(() => {\n    constructTheNameChangeMessage();\n  }, [constructTheNameChangeMessage]);\n\n  return (\n    <div className=\"container\">\n      <div className=\"row\">\n        <div className=\"col-sm-12\" style={{ textAlign: 'center', padding: 30 }}>\n          <h1>{header}</h1>\n          <p>My name is {mySelf.name} and I am {mySelf.age} years of age.</p>\n          <button className=\"btn btn-primary\" onClick={changeNameToJohn}>Change My Name To John</button>\n        </div>\n      </div>\n    </div>\n  );\n}\nexport default App;\n\nFigure 4 shows an updated version of the first example (figure 1). It contains an effect that executes a method constructTheNameChangeMessage(). It gets wrapped in a callback to return memorized output that changes only when the object mySelf changes (as declared in the dependency array).\n\nThe header should change its value when the button clicks, but it doesn’t.\n\nIt occurs because of Referential Equality. React applies the Object.is() algorithm and classifies the present mySelf equal with the new value. Therefore, the method - constructTheNameChangeMessage does not return a new memorized version as the values in its dependency array remains unchanged. As a result, the effect does not get executed because the memorized callback does not change.\n\nIt introduces a chain of bugs in the code that can negatively affect the user experience. Therefore, it is crucial to address this issue to re-render React components as expected.\n\n\nUsing Referential Equality with React\n\nAccording to the principle of Object.is(), any two objects pointing to the exact memory location are considered equal. Considering this, implementing the fix is straightforward.\n\nConsider the fix shown below:\n\nconst changeNameToJohn = () => {\n   setMySelf({ ...mySelf, name: 'John' });\n}\n\nWhen the previous code gets replaced with the updated code shown above, we see the output below once the button clicks.\n\nFigure 5 shows the state updating and re-rendering successfully as the new state update gets reflected in the UI.\n\nBut, what has changed?\n\nWhen the new event handler is observed, the object — { ...mySelf, name: 'John'} gets passed directly into the method - setMySelf to update the state. By doing so, a new object gets passed into the method rather than updating the existing object.\n\nTherefore, when React applies the Object.is() algorithm, the value that gets passed is not equal to the current value stored in mySelf because the new object points to another memory location. As a result, it causes the state to get updated, creating a chain reaction within the React ecosystem.\n\nThis state update will:\n\n 1. Make React return a new memorized output of constructTheNameChangeMessage because the values declared in its dependency array change.\n 2. Cause React to execute the effect -useEffect as the callback returned a new memorized output.\n 3. Re-render the component to reflect the new state.\n\nSince the state gets successfully rendered on the user interface, it helps keep the user informed of all changes in the application allowing it to function as expected.\n\nSource https://blog.bitsrc.io/understanding-referential-equality-in-react-a8fb3769be0","html":"<h2 id=\"what-is-referential-equality-why-it-is-useful-to-understand-and-how-referential-equality-affects-component-re-rendering-in-react\">What is referential equality? Why it is useful to understand, and how referential equality affects component re-rendering in React</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/875/0*B0tdphf9yXLlOcUN.jpg\" class=\"kg-image\" alt loading=\"lazy\" width=\"700\" height=\"413\"></figure><p>In React, state variables are used to render the component state on the browser. When the state changes, React re-renders the component with the new data. It helps keep the user informed of all changes occurring in the application.</p><p>However, many React developers do not manage the state variables properly. This results in re-renders not occurring despite the state changing. It will then make an awful user experience in the application.</p><p>Therefore, this article will explain how React re-renders a component and what we can do to ensure that the state changes get reflected in the UI smoothly.</p><h1 id=\"how-does-react-determine-a-component-re-render\">How Does React Determine a Component Re-Render?</h1><p>React re-renders a component only when a change occurs to its state variables or props.</p><p>This is shown in the example given below:</p><pre><code class=\"language-javascript\">const [name, setName] = useState('');\nconst onButtonClick = (newName: string)=&gt; {\n   setName(newName);\n};</code></pre><p>The code snippet displayed above has a method named <code>onButtonClick</code> that updates the state variable - <code>name</code> with a new value.</p><p>React compares the new value against the old value for equality using the <code>Object.is()</code> comparison algorithm whenever a new value is assigned to <code>name </code>variable.</p><p>If the values are equal, React bails out the re-render. But if the values are different, React triggers a component re-render to reflect the state change.</p><h1 id=\"the-comparison-algorithm-%E2%80%94-objectis\">The Comparison Algorithm — Object.is()</h1><p>The <code>Object.is()</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#description\" rel=\"noopener ugc nofollow\">algorithm</a> determines whether two values are the same if:</p><ol><li>Both values are <code>undefined</code> or <code>null</code>.</li><li>Both values are either <code>true</code> or <code>false</code>.</li><li>Both values are <code>Strings</code> having the same characters, length, and order.</li><li>Both values are <code>Numbers</code> with the same value or <code>NaN</code>.</li><li>Both values are <code>Objects</code> that point to one memory location.</li></ol><p>React applies these rules to re-render components whenever a state change is made.</p><h1 id=\"the-comparison-algorithm-in-action-%E2%80%94-referential-equality\">The Comparison Algorithm in Action — Referential Equality</h1><p>Consider the code shown below to identify how developers can introduce bugs with state management using React to understand <code>Object.is()</code> better.</p><pre><code class=\"language-typescript\">import { useState } from 'react';\nimport './App.css';\n\nconst App = () =&gt; {\n  const [mySelf, setMySelf] = useState&lt;{ name: string, age: number }&gt;({ name: 'David', age: 30 });\n\n  const changeNameToJohn = () =&gt; {\n    mySelf.name = \"John\";\n    mySelf.age = 30;\n    console.log(mySelf);\n    setMySelf(mySelf)\n  }\n\n  return (\n    &lt;div className=\"container\"&gt;\n      &lt;div className=\"row\"&gt;\n        &lt;div className=\"col-sm-12\" style={{ textAlign: 'center', padding: 30 }}&gt;\n          &lt;p&gt;My name is {mySelf.name} and I am {mySelf.age} years of age.&lt;/p&gt;\n          &lt;button className=\"btn btn-primary\" onClick={changeNameToJohn}&gt;Change My Name To John&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;</code></pre><p>The code snippet above shows a state variable named <code>mySelf</code> initialized as an object with properties <code>name</code> and <code>age</code> set to \"David\" and \"30\", respectively. Furthermore, an event listener named <code>changeNameToJohn</code> is declared to change the <code>name</code> to a new value, \"John.\"</p><p>The output of this code is shown below:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://miro.medium.com/max/875/0*xm6pBOKVcoQfm6C7.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"700\" height=\"152\"><figcaption><strong class=\"bd lp\" style=\"box-sizing: inherit; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-weight: 600;\">Figure 2. Expected output of code snippet</strong></figcaption></figure><p>When the button clicks, the name should change to “John” and trigger a re-render to update the UI.</p><p>But, currently, it does not happen even-though logging the object displays the updated values, as shown below:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://miro.medium.com/max/875/0*M-m48KpyEaHgKnth.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"700\" height=\"307\"><figcaption><strong class=\"bd lp\" style=\"box-sizing: inherit; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-weight: 600;\">Figure 3. Observing the console after the button gets clicked</strong></figcaption></figure><p>Many of you may wonder why the component does not get re-rendered. Looking at the fifth principle of the <code>Object.is()</code> algorithm may help you understand this situation.</p><blockquote><em><em><em>Two values are considered equal when both are objects that point to the exact memory location.</em></em></em></blockquote><p>With the help of this principle, the bug in the above code can be identified.</p><pre><code class=\"language-javascript\">const changeNameToJohn = () =&gt; {\n   mySelf.name = \"John\";\n   mySelf.age = 30;\n   console.log(mySelf);\n   setMySelf(mySelf);\n};</code></pre><p>During the state change shown above, it assigns the new name to the property of the current object. When the comparison algorithm gets applied by React, the new and current values will still be equal because, behind the scenes, the two values point to the exact memory location.</p><p>Therefore, React classifies these values as equal and does not trigger a re-render. Hence, the UI does not reflect the state change.</p><p>This process is called <strong><strong>Referential Equality, </strong></strong>for objects are considered equal based on their memory location and not the values.</p><h1 id=\"problems-with-the-referential-equality\">Problems with the Referential Equality</h1><p>Ignoring the Referential Equality introduces minor bugs as discussed above. But, when developing React components, we use effects (<code>useEffect</code>) and memorized callbacks (<code>useCallback</code>) that get triggered only when a value in their dependency array changes.</p><p>One minor state management error creates numerous bugs throughout the component in situations like this.</p><p>For example, consider the code snippet shown below:</p><pre><code class=\"language-javascript\">import { useCallback, useEffect, useState } from 'react';\nimport './App.css';\n\nconst App = () =&gt; {\n  const [mySelf, setMySelf] = useState&lt;{ name: string, age: number }&gt;({ name: 'David', age: 30 });\n  const [header, setHeader] = useState&lt;string&gt;('Hello David!');\n\n  const changeNameToJohn = () =&gt; {\n    mySelf.name = \"John\";\n    mySelf.age = 30;\n    console.log(mySelf);\n    setMySelf(mySelf);\n  }\n  const constructTheNameChangeMessage = useCallback(() =&gt; {\n    if (mySelf) {\n      setHeader(`Hello ${mySelf.name}!`);\n    }\n  }, [mySelf]);\n\n  useEffect(() =&gt; {\n    constructTheNameChangeMessage();\n  }, [constructTheNameChangeMessage]);\n\n  return (\n    &lt;div className=\"container\"&gt;\n      &lt;div className=\"row\"&gt;\n        &lt;div className=\"col-sm-12\" style={{ textAlign: 'center', padding: 30 }}&gt;\n          &lt;h1&gt;{header}&lt;/h1&gt;\n          &lt;p&gt;My name is {mySelf.name} and I am {mySelf.age} years of age.&lt;/p&gt;\n          &lt;button className=\"btn btn-primary\" onClick={changeNameToJohn}&gt;Change My Name To John&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\nexport default App;</code></pre><p>Figure 4 shows an updated version of the first example (figure 1). It contains an effect that executes a method <code>constructTheNameChangeMessage()</code>. It gets wrapped in a callback to return memorized output that changes only when the object <code>mySelf</code> changes (as declared in the dependency array).</p><p>The header should change its value when the button clicks, but it doesn’t.</p><p>It occurs because of <strong><strong>Referential Equality</strong></strong>. React applies the <code>Object.is()</code> algorithm and classifies the present <code>mySelf</code> equal with the new value. Therefore, the method - <code>constructTheNameChangeMessage</code> does not return a new memorized version as the values in its dependency array remains unchanged. As a result, the effect does not get executed because the memorized callback does not change.</p><p>It introduces a chain of bugs in the code that can negatively affect the user experience. Therefore, it is crucial to address this issue to re-render React components as expected.</p><h1 id=\"using-referential-equality-with-react\">Using Referential Equality with React</h1><p>According to the principle of <code>Object.is()</code>, any two objects pointing to the exact memory location are considered equal. Considering this, implementing the fix is straightforward.</p><p>Consider the fix shown below:</p><pre><code class=\"language-javascript\">const changeNameToJohn = () =&gt; {\n   setMySelf({ ...mySelf, name: 'John' });\n}</code></pre><p>When the previous code gets replaced with the updated code shown above, we see the output below once the button clicks.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://miro.medium.com/max/875/0*FbTLl9YmuAGcvlGi.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"700\" height=\"168\"><figcaption><strong class=\"bd lp\" style=\"box-sizing: inherit; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-weight: 600;\">Figure 5. Output of the updated code</strong></figcaption></figure><p>Figure 5 shows the state updating and re-rendering successfully as the new state update gets reflected in the UI.</p><p><strong><strong>But, what has changed?</strong></strong></p><p>When the new event handler is observed, the object — <code>{ ...mySelf, name: 'John'}</code> gets passed directly into the method - <code>setMySelf</code> to update the state. By doing so, a new object gets passed into the method rather than updating the existing object.</p><p>Therefore, when React applies the <code>Object.is()</code> algorithm, the value that gets passed is not equal to the current value stored in <code>mySelf</code> because the new object points to another memory location. As a result, it causes the state to get updated, creating a chain reaction within the React ecosystem.</p><p>This state update will:</p><ol><li>Make React return a new memorized output of <code>constructTheNameChangeMessage</code> because the values declared in its dependency array change.</li><li>Cause React to execute the effect -<code>useEffect</code> as the callback returned a new memorized output.</li><li>Re-render the component to reflect the new state.</li></ol><p>Since the state gets successfully rendered on the user interface, it helps keep the user informed of all changes in the application allowing it to function as expected.</p><p>Source <a href=\"https://blog.bitsrc.io/understanding-referential-equality-in-react-a8fb3769be0\">https://blog.bitsrc.io/understanding-referential-equality-in-react-a8fb3769be0</a></p>","url":"https://portfolioghost.phonemall.pk/understanding-referential-equality-in-react/","canonical_url":null,"uuid":"103f08e3-7b25-43a4-ab4a-0e3d26e6241e","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"63b16ba1bb0c2e69d86452bb","reading_time":6}}]}},"pageContext":{"slug":"javascript","pageNumber":0,"humanPageNumber":1,"skip":0,"limit":48,"numberOfPages":1,"previousPagePath":"","nextPagePath":""}},"staticQueryHashes":["1752937443","2358152166","2561578252","2731221146","4145280475"]}